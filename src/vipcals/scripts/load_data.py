import numpy as np
import os
import math
import pandas as pd

from astropy.io import fits
from astropy.table import Table

from AIPS import AIPS
from AIPSTask import AIPSTask, AIPSList

#from AIPSData import AIPSUVData, AIPSImage
#import Wizardry.AIPSData as wizard

class Source():
    """Sources within a fits file."""
    def __init__(self):
        self.name = None
        self.id = None
        self.inlist = None
        self.restfreq = None
        self.band = None
        self.band_flux = None
        
    def set_band(self):
        """Set band name depending on rest frequency."""
        if self.restfreq < 3e9:
            self.band = 'S'
        elif self.restfreq < 7e9:
            self.band = 'C'
        elif self.restfreq < 1e10:
            self.band = 'X'
        elif self.restfreq < 1.8e10:
            self.band = 'U'
        else:
            self.band = 'K'


def open_log(name):
    """Create a directory and a _log.txt file."""
    if os.path.exists('./' + name) == False:
        os.system('mkdir ' + name)
    AIPS.log = open('./' + name + '/' + name + '_AIPS_log.txt', 'w')

def get_source_list(file_path, freq = 0):
    """Get a source list from a fits file.
    
    It returns a list of Source objects.
    """    
    hdul = fits.open(file_path)
    full_source_list = []
    for elements in Table(hdul['SOURCE'].data):
        a = Source()
        a.name = elements['SOURCE']
        try:
            a.id = elements['ID_NO.']
        except KeyError:
            a.id = elements['SOURCE_ID']
        try:
            a.restfreq = elements['RESTFREQ'][0]
        except IndexError: # Single IF datasets
            a.restfreq = elements['RESTFREQ']      
            
        # Frequency can be given as an input
        if freq != 0:
            a.restfreq = freq
            
        a.set_band()      
        full_source_list.append(a)
        a = None        
        
    # Make sure that source names are ASCII characters
    for s in full_source_list:
        name_string = s.name
        s.name = ''.join(char for char in name_string \
                         if ord(char) < 128).rstrip('\x00')
    
    return(full_source_list)


def find_calibrators(full_source_list):
    """Choose possible calibrators from a source list.

    It loads information of ~ 9000 sources from an external file.
    Then, checks if there is available flux information for the
    sources in the source list generated by the get_source_list() 
    function. If there are more than 3 observed sources, the names 
    of the brightest 3 are given in return. If not, only the 
    brighthest source is returned.
    """
    col_names = ['NameJ2000', 'NameB1950', 'NameICRF3', 'NameOther','RA',\
                 'DEC', 'RAE', 'DECE', 'S_short', 'S_long', 'C_short',\
                 'C_long', 'X_short', 'X_long', 'U_short', 'U_long',\
                 'K_short', 'K_long', 'Ka', 'Ref']

    calib_list = pd.read_fwf('./vlbaCalib_allfreq_full.txt', skiprows = 16,\
                             names = col_names)

    
    for elements in full_source_list:
        row = calib_list.loc[calib_list.isin([elements.name]).any(axis=1)]
        try:
            elements.band_flux = float(row.iloc[0][elements.band + '_short'])
        except:
            elements.band_flux = np.NaN
        
    full_source_list.sort(key = lambda x: 0 if math.isnan(x.band_flux)\
                          else x.band_flux, reverse = True)

    if len(full_source_list) > 3:
        return [str(full_source_list[0].name),str(full_source_list[1].name),\
                str(full_source_list[2].name)]
            
    # If there are 3 or less sources just load all 
    else:
        calibs = []
        for src in full_source_list:
            calibs.append(src.name)
        return(calibs)
    
    # Might not be optimal if the dataset has very different frequencies...
    
def is_it_multifreq_id(file_path):
    """Check if the file contains multiple bands splitted in IDs.
    
    Returns:
        multifreq: (boolean) True if the dataset has multiple bands, False if 
                    not
        howmanyids: (int) number of ids
        bands: (list of float) frequency of each id
        """
    multifreq = False
    hdul = fits.open(file_path)
    howmanyids = len(hdul['FREQUENCY'].data['FREQID'])
    bands = []
    if howmanyids > 1:
        for i in range(howmanyids):
            freq = np.floor(hdul['SOURCE'].data['RESTFREQ'][0] \
                            + hdul['FREQUENCY'].data['BANDFREQ'][i])
            if freq[0] > 1e10:
                bands.append(freq[0])
            else:
                bands.append(freq[0])
        multifreq = True
    return (multifreq, howmanyids, bands)

def is_it_multifreq_if(file_path):
    """Check if the file contains multiple bands splitted in IFs.
    
    Looks at the central frequency of all IFs and looks for jumps of
    more than 1 GHz between them. Only works for datasets with 1 or 2
    frequency bands, not more.
    
    Returns:
        multifreq: (boolean) True if the dataset has multiple bands, False if 
                    not
        1: (int) Value of the first IF, always 1
        IF: (int) value of the last IF of band 1
        IF+1: (int) value of the first IF of band 2            
        len(if_freq[0]): (int) value of the last IF of band 2
        str(freq_1)[0]: (str) first digit of the frequency of band 1
        str(freq_2)[0]: (str) first digit of the frequency of band 2
        freq_1: (float) frequency of band 1
        freq_2: (float) frequency of band 2
    """
    multifreq = False
    hdul = fits.open(file_path)
    if_freq = hdul['SOURCE'].data['RESTFREQ'][0] \
              + hdul['FREQUENCY'].data['BANDFREQ']
    if isinstance(if_freq[0], np.float64) == True:
        # Data is single IF
        if if_freq[0] > 1e10:
            freq = str(if_freq[0])[:2] 
        else:
            freq = str(if_freq[0])[:1] 
        return(False, 1, 1, 1, 1, freq, freq)
               
    for IF,freq in enumerate(if_freq[0]):
        if IF == 0:
            continue
        if abs(freq - if_freq[0][IF-1]) > 1e9 :
            multifreq = True
            break
    freq_1 = np.floor(if_freq[0][0])
    freq_2 = np.floor(if_freq[0][-1])
    return(multifreq, 1, IF, IF+1, len(if_freq[0]), str(freq_1)[0],\
           str(freq_2)[0], freq_1, freq_2)
        

def load_data(file_path, name, sources, disk, multi_id, selfreq, klass = '', \
              seq = 0, bif = 0, eif = 0):
    """Load data from a uvfits/idifits file.
    
    Arguments:
    ---------
    
    file_path: (str)
        path to the fits file
        
    name: (str)
        file name within AIPS
        
    sources: list of (str)
        list of sources to accept
    
    disk: (int)
        disk number within AIPS.
    
    klass: (str)
        class name within AIPS. Default = '' 
    
    seq: (int)
        sequence number within AIPS. Default = 0
    
    bif: (int)
        first IF to copy. 0 => 1. Default = 0
    
    eif: (int)
        highest IF to copy. 0 => all higher than bif. Default = 0   
    """              
    fitld = AIPSTask('fitld')
    fitld.datain = file_path
    fitld.outname = name
    fitld.outdisk = disk
    fitld.outclass = klass
    fitld.outseq = seq
    fitld.sources = AIPSList(sources)
    fitld.bif = bif
    fitld.eif = eif
    fitld.clint = 0.1
    fitld.msgkill = -4
    if multi_id == True:
        fitld.selfreq = float(selfreq)    
    fitld.go()

def print_listr(data, log):
    """Print scan information in an external file."""
    listr = AIPSTask('listr')
    listr.inname = data.name
    listr.inclass = data.klass
    listr.indisk = data.disk
    listr.inseq = data.seq
    
    listr.optype = 'SCAN'
    listr.xinc = 1
    listr.docrt = -2
    listr.outprint = './' + log.name.split('/')[1] + '/scansum.txt'
    listr.msgkill = -4
    
    listr.go()
    
    log.write('\nScan information printed in /scansum.txt \n')